탐색이란?

컴퓨터 프로그램에서 탐색은 하나 이상의 필드(field)로 구성되는 레코드(record)의 집합에서 원하는 레코드를 찾아내는 작업이다
이러한 레코드를 테이블(table)이라고 부른다.레코드들은 서로 중복되지 않고 고유한 값을 가지는 키를 가지는데, 이것을 탐색키(search key)라고 한다.
결국 자료를 검색하는 것은 테이블에서 원하는 탐색키를 가진 레코드를 찾는 것이다.

맵 이란?

맵은 탐색을 위한 자료구조이다. 맵(map)또는 사전(dictionary)은 자료를 저장하고 키를 이용해 원하는 자료를 빠르게 찾을 수 있도록 하는 자료구조를 말한다.
맵은 키를 가진 레코드(keyed record)또는 엔트리(entry)라 불리는 키-값 쌍(key,value)을 테이블에 저장한다.


Keyed Record

객체: 키(key)와 값(value)을 가진 요소 (key,value)의 집합
연산 create(key,value):주어진 key와 value를 각각 키와 값으로 갖는 레코드를 생성한다.
     getKey(): 레코들의 키를 반환한다.
     getValue(): 레코들의 값을 반환한다.
     update(value): 레코들의 값을 value로 변경한다.



Map

객체: 유일한 키를 가진 엔트리(키를 가진 레코드)의 집합
연산: create(): 공백 상태의 맵을 생성한다.
      search(key): 테이블에서 주어진 탐색 key를 가진 레코드를 찾아 반환한다.
      insert(entry): 테이블에서 주어진 entry를 삽입한다.
      delete(key): 테이블에서 주어진 탐색키 key를 가진 레코드를 찾아 삭제한다.
      count(): 테이블의 모든 레코드 수를 반환한다.



맵을 구현하는 가장 간단한 방법은 배열이다 하지만 맵의 탐색 성능을 고려하면 이진 탐색 트리와 같은 보다 효율적인 자료구조를 고려해야한다.
맵은 구현하는 4가지 방법이 있다.

(1)정렬되지 않은 배열을 사용하는 방법
(2)정렬된 배열을 이용하는 방법
(3)이진 탐색 트리를 이용하는 방법
(4)해싱을 이용하는 방법





정렬되지 않은 배열에서의 탐색

순차 탐색

순차탐색(sequential search)는 가장 간단하고 직접적인 탐색 방법이다.배열의 요소들을 처음부터 마지막까지 하나씩 검사하여 원하는 레코드를 찾는 방법이다.


```cpp

//int 배열 list의 순차탐색

int sequentialSearch(int list[], int key, int low, int high){

          for(int i=low;i<=high;i++)
                if(list[i]==key)
                   return i;          //탐색에 성공하면 키 값의 인덱스를 반환

         return -1;                  //탐색에 실패하면 -1을 반환

}

```





![Image](https://github.com/user-attachments/assets/ce79b365-2f71-4d87-ae31-772953d1ddd1)

출처: 구글 순차 탐색







정렬된 배열에서의 탐색

배열이 정렬되어 있으면 순차 탐색 실행 중에서 탐색키보다 큰 레코드를 만나면 탐색을 종료할 수 있으므로 배열 전체를 검색하지 않고도 탐색 항목의 존재 유무를 알 수 있다.


```cpp

//오름차순으로 정렬된 배열 list의 순차탐색
int sortedSequentialSearch(int list[], int key, int low, int high){

      int i;
      if(key<list[low] || key>list[high]) return -1;
      for(i=low; i<=high;i++){
          if(list[i]>key) return -1;
          if(list[i] ==key) return 1;
      }
}
```




정렬된 배열의 탐색에서는 이진 탐색(binary search)이 적용될 수 있다.이 방법은 배열의 중앙에 있는 값을 조사하여 찾고자 하는 항목이 왼쪽 부분 배열에 있는지 오른쪽 부분 배열에 있는지 판단하고 
다음 단계의 탐색 범위를 반으로 줄인다.따라서 매 단계에서 탐색해야 할 리스트의 크기가 반으로 줄어든다
이진 탐색하기 전에 반드시 배열이 정렬되어 있어야 한다.따라서 이진 탐색은 데이터의 삽입과 삭제가 빈번한 경우에는 적합하지 않다.

이진 탐색을 유사코드로 작성하면 list[low]부터 list[high] 사이에서 key를 찾는다고 가정하면 

```cpp

search_binary(list,low,high,key)

   middle <- low에서 high 사이의 중간의 위치
   if( 탐색값 = list[middle] )
         return middle;
   else if( 탐색값 < list[middle] )
         return search_binary(list,low,middle-1,key);
   else if( 탐색값 < list[middle] )
         return search_binary(list, middle+1,high,key);

   return -1

```


색인 순차 탐색

색인 순차 탐색(indexed sequential search) 방법은 인덱스(index)라 불리는 테이블을 사용하여 탐색의 효율을 높이는 방법이다
인덱스 테이블에서 index[i] <= key < index[i+1]을 만족하는 항목을 찾는다.



![Image](https://github.com/user-attachments/assets/b6e8c930-5e4f-4ddf-88e8-b56291776f83)

출처:구글 색인 순차 탐색의 예





보간 탐색
보간 탐색(interpolation search)은 사전이나 전화번호부를 탐색하는 방법과 같이 탐색키가 존재할 위치를 예측하여 탐색하는 방법이다.
이진 탐색과 유사하나 리스트를 반으로 분할하지 않고 불균등하게 분할하여 탐색한다.
그림과 같이 탐색 값과 위치는 비례한다는 가정에서 탐색 위치를 결정할때 찾고자 하는 키값이 있는 곳에 근접하도록 가중치를 주는 방법이다 



![Image](https://github.com/user-attachments/assets/8d7d7ec5-8042-4e26-b5d3-0d00389d1d7c)

출처: 구글 보간 탐색의 탐색위치






균형 이진 탐색 트리

맵은 이진 탐색 트리로도 구현할 수 있다.이진 탐색에서는 자료는 배열에 저장되어 있으므로 삽입과 삭제가 힘들지만 맵에 자료를 삽입하거나 삭제할때 
불필요한 항목들의 많은 이동이 필요하다.반면에 맵을 이진 탐색 트리로 구현하면 O(logn) 시간에 삽입과 삭제가 가능하다.
그러므로 삽입과 삭제가 빈번하다면 이진 탐색 트리를 사용하여야 한다.











AVL트리란?

AVL트리는 각 노드에서 왼쪽 서브트리의 높이와 오른쪽 서브트리의 높이 차이가 1이하인 이진 탐색트리를 말한다.이 트리는 트리가 비균형 상태로 되면 스스로 노드들을 재배치하여 균형 상태로 만든다.
AVL트리는 항상 균형 트리를 보장하기 때문에 O(logn)의 탐색 시간을 보장한다.삽입과 삭제 연산도 O(logn)시간안에 할 수 있다.

<img width="746" alt="Image" src="https://github.com/user-attachments/assets/c672eed0-fa0a-4312-aba0-8d88a028c582" />

출처: 구글 균형트리




AVL 트리의 삽입 연산

삽입 후의 AVL트리의 균형이 깨진 트리를 다시 균형있게 만들려면 서브트리를 회전시키면 된다.

AVL 트리에서 균형이 깨지는 경우는 다음의 4가지 경우가 있다.새로 삽입된 노드 N으로부터 가장 가까우면서 균형 인수가 +-2가 된 조상 노드를 A라고 하자

LL타입:N이 A의 왼쪽 서브트리의 왼쪽 서브트리에 삽입된다
LR타입:N이 A의 왼쪽 서브트리의 오른쪽 서브트리에 삽입된다.
RR타입:N이 A의 오른쪽 서브트리의 왼쪽 서브트리에 삽입된다.
RL타입:N이 A의 오른쪽 서브트리의 오른쪽 서브트리에 삽입된다.

다음의 각각의 경우를 균형 트리로 다시 만드는 방법이다.

LL회전:A부터 N까지의 경로상의 노드들을 오르쪽으로 회전시킨다.
LR회전:A부터 N까지의 경로상의 노드들을 왼쪽-오른쪽으로 회전시킨다.
RR회전:A부터 N까지의 경로상의 노드들을 왼쪽으로 회전시킨다.
RL회전:A부터 N까지의 경로상의 노드들을 오른쪽-왼쪽으로 회전시킨다.\


한번만 회전시키는 것을 단순 회전(single rotaion)이라고 하고 LL회전,RR회전이 여기에 속한다.
이경우 탐색 순서를 유지하면서 부모와 자식의 위치를 교환하면 된다.
두번의 회전이 필요한 경우 이중 회전(double rotation)이라고 하고 LR회전,RL회전이 여기에 속한다.
LL회전과 RR회전은 방향만 반대이고 대칭이먀 LR회전과 RL회전 역시 방향만 반대이고 대칭이다






LL회전

LL타입은 조상 노드 A의 왼쪽 서브 트리의 왼쪽 서브트리에 노드가 추가됨으로서 발생한다

![Image](https://github.com/user-attachments/assets/58dc2df5-5139-4b1e-bac3-148d959d961c)

출처: 구글 LL회전



RR회전

RR타입은 조상노드 A의 오른쪽 서브트리의 오른쪽 서브트리에 노드가 추가됨으로서 발생한다.
회전한다는 의미는 부모 노드와 자식 노드를 바꾼다는 것이다.

![Image](https://github.com/user-attachments/assets/0b0d09e6-e866-4afc-945b-16c169fd1b49)

출처: 구글 RR회전



RL회전

RL타입은 조상 노드 A의 오른쪽 서브트리의 왼쪽 서브트리에 노드가 추가됨으로서 발생한다.
RL회전은 균형트리를 만들기 위하여 2번의 회전이 필요하다.RL 회전은 LL회전을 한 다음, RR회전을 하면 된다.

![Image](https://github.com/user-attachments/assets/b221b68e-835f-467a-bf23-dd590c35d30a)

출처: 구글 RL회전


LR회전 

LR타입은 조상 노드 A의 왼쪽 서브트리의 오른쪽 서브트리에 노드가 추가됨으로서 발생한다.
LR회전은 균형트리를 만들기 위하여 2번의 회전이 필요하다.LR회전은 RR회전을 한다음 LL회전을 하면 된다.

![Image](https://github.com/user-attachments/assets/eeee2dfb-87fe-4125-92e9-a9dce6723ab3)

출처: 구글 LR회전





해싱을 이용한 탐색 






