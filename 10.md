# 탐색이란?

컴퓨터 프로그램에서 탐색은 하나 이상의 필드(field)로 구성되는 레코드(record)의 집합에서 원하는 레코드를 찾아내는 작업입니다. 이러한 레코드를 **테이블(table)**이라고 부릅니다. 레코드들은 서로 중복되지 않고 고유한 값을 가지는 키를 가지는데, 이것을 **탐색키(search key)**라고 합니다. 결국 자료를 검색하는 것은 테이블에서 원하는 탐색키를 가진 레코드를 찾는 것입니다.

# 맵이란?


**맵(map)** 또는 **사전(dictionary)**은 탐색을 위한 자료구조입니다. 맵은 자료를 저장하고 키를 이용해 원하는 자료를 빠르게 찾을 수 있도록 하는 자료구조를 말합니다. 맵은 키를 가진 레코드(keyed record) 또는 엔트리(entry)라 불리는 키-값 쌍(key, value)을 테이블에 저장합니다.

## Keyed Record

- **객체**: 키(key)와 값(value)을 가진 요소 (key, value)의 집합
- **연산**:
  - `create(key, value)`: 주어진 key와 value를 각각 키와 값으로 갖는 레코드를 생성합니다.
  - `getKey()`: 레코드의 키를 반환합니다.
  - `getValue()`: 레코드의 값을 반환합니다.
  - `update(value)`: 레코드의 값을 value로 변경합니다.

## Map

- **객체**: 유일한 키를 가진 엔트리(키를 가진 레코드)의 집합
- **연산**:
  - `create()`: 공백 상태의 맵을 생성합니다.
  - `search(key)`: 테이블에서 주어진 탐색 key를 가진 레코드를 찾아 반환합니다.
  - `insert(entry)`: 테이블에서 주어진 entry를 삽입합니다.
  - `delete(key)`: 테이블에서 주어진 탐색키 key를 가진 레코드를 찾아 삭제합니다.
  - `count()`: 테이블의 모든 레코드 수를 반환합니다.


# 맵 구현 방법

맵을 구현하는 가장 간단한 방법은 배열입니다. 하지만 맵의 탐색 성능을 고려하면 이진 탐색 트리와 같은 보다 효율적인 자료구조를 고려해야 합니다. 맵은 구현하는 4가지 방법이 있습니다.

1. **정렬되지 않은 배열을 사용하는 방법**
   - 배열에 키-값 쌍을 저장하되, 키의 순서가 정렬되어 있지 않습니다. 탐색 시 전체 배열을 순회해야 하므로 성능이 낮습니다.

2. **정렬된 배열을 이용하는 방법**
   - 배열에 키-값 쌍을 정렬된 상태로 저장합니다. 이진 탐색을 통해 탐색 성능을 개선할 수 있지만, 삽입 및 삭제 시 배열을 재정렬해야 하므로 비용이 발생합니다.

3. **이진 탐색 트리를 이용하는 방법**
   - 이진 탐색 트리를 사용하여 키-값 쌍을 저장합니다. 탐색, 삽입, 삭제 모두 평균적으로 O(log n)의 성능을 보장합니다.

4. **해싱을 이용하는 방법**
   - 해시 함수를 사용하여 키를 해시 값으로 변환하고, 이를 통해 배열의 인덱스를 결정합니다. 평균적으로 O(1)의 탐색 성능을 제공하지만, 해시 충돌이 발생할 수 있어 이를 처리하는 방법이 필요합니다.





# 정렬되지 않은 배열에서의 탐색

## 순차 탐색

순차 탐색(sequential search)은 가장 간단하고 직접적인 탐색 방법입니다. 배열의 요소들을 처음부터 마지막까지 하나씩 검사하여 원하는 레코드를 찾는 방법입니다.

### C++ 코드 예시

```cpp
// int 배열 list의 순차탐색
int sequentialSearch(int list[], int key, int low, int high) {
    for (int i = low; i <= high; i++) {
        if (list[i] == key)
            return i;  // 탐색에 성공하면 키 값의 인덱스를 반환
    }
    return -1;  // 탐색에 실패하면 -1을 반환
}
```





![Image](https://github.com/user-attachments/assets/ce79b365-2f71-4d87-ae31-772953d1ddd1)

출처: 구글 순차 탐색





# 정렬된 배열에서의 탐색

배열이 정렬되어 있으면 순차 탐색 실행 중에서 탐색 키보다 큰 레코드를 만나면 탐색을 종료할 수 있으므로 배열 전체를 검색하지 않고도 탐색 항목의 존재 유무를 알 수 있습니다.

## C++ 코드 예시: 정렬된 배열의 순차 탐색

```cpp
// 오름차순으로 정렬된 배열 list의 순차탐색
int sortedSequentialSearch(int list[], int key, int low, int high) {
    int i;
    if (key < list[low] || key > list[high]) return -1;
    for (i = low; i <= high; i++) {
        if (list[i] > key) return -1;
        if (list[i] == key) return 1;
    }
}
```






# 이진 탐색 (Binary Search)

정렬된 배열의 탐색에서는 **이진 탐색**(binary search)이 적용될 수 있습니다. 이 방법은 배열의 중앙에 있는 값을 조사하여 찾고자 하는 항목이 왼쪽 부분 배열에 있는지 오른쪽 부분 배열에 있는지 판단하고, 다음 단계의 탐색 범위를 반으로 줄입니다. 따라서 매 단계에서 탐색해야 할 리스트의 크기가 반으로 줄어듭니다.

이진 탐색을 수행하기 전에 반드시 배열이 정렬되어 있어야 하며, 데이터의 삽입과 삭제가 빈번한 경우에는 적합하지 않습니다.

## 이진 탐색 유사코드

이진 탐색을 유사코드로 작성하면 다음과 같습니다:

```plaintext
search_binary(list, low, high, key)
    middle <- low에서 high 사이의 중간의 위치
    if (탐색값 = list[middle])
        return middle;
    else if (탐색값 < list[middle])
        return search_binary(list, low, middle - 1, key);
    else
        return search_binary(list, middle + 1, high, key);
    
    return -1
```



# 색인 순차 탐색 (Indexed Sequential Search)

색인 순차 탐색(indexed sequential search) 방법은 **인덱스**(index)라 불리는 테이블을 사용하여 탐색의 효율을 높이는 방법입니다. 이 방법에서는 인덱스 테이블에서 `index[i] <= key < index[i+1]`을 만족하는 항목을 찾습니다.

![색인 순차 탐색 예시](https://github.com/user-attachments/assets/b6e8c930-5e4f-4ddf-88e8-b56291776f83)

출처: 구글 색인 순차 탐색의 예




# 보간 탐색 (Interpolation Search)

보간 탐색(interpolation search)은 사전이나 전화번호부를 탐색하는 방법과 같이 탐색키가 존재할 위치를 예측하여 탐색하는 방법입니다. 이 방법은 이진 탐색과 유사하지만, 리스트를 반으로 분할하지 않고 불균등하게 분할하여 탐색합니다.

그림과 같이 탐색 값과 위치는 비례한다는 가정에서 탐색 위치를 결정할 때, 찾고자 하는 키값이 있는 곳에 근접하도록 가중치를 주는 방법입니다.

![보간 탐색 탐색 위치](https://github.com/user-attachments/assets/8d7d7ec5-8042-4e26-b5d3-0d00389d1d7c)

출처: 구글 보간 탐색의 탐색 위치







# 균형 이진 탐색 트리

맵은 이진 탐색 트리로도 구현할 수 있습니다. 이진 탐색에서는 자료가 배열에 저장되어 있으므로 삽입과 삭제가 힘들지만, 맵에 자료를 삽입하거나 삭제할 때 불필요한 항목들의 많은 이동이 필요합니다. 반면에 맵을 이진 탐색 트리로 구현하면 O(log n) 시간에 삽입과 삭제가 가능합니다. 그러므로 삽입과 삭제가 빈번하다면 이진 탐색 트리를 사용해야 합니다.

## AVL 트리란?

AVL 트리는 각 노드에서 왼쪽 서브트리의 높이와 오른쪽 서브트리의 높이 차이가 1 이하인 이진 탐색 트리를 말합니다. 이 트리는 트리가 비균형 상태가 되면 스스로 노드들을 재배치하여 균형 상태로 만듭니다. AVL 트리는 항상 균형 트리를 보장하기 때문에 O(log n)의 탐색 시간을 보장합니다. 삽입과 삭제 연산도 O(log n) 시간 안에 할 수 있습니다.

![AVL 트리](https://github.com/user-attachments/assets/c672eed0-fa0a-4312-aba0-8d88a028c582)

출처: 구글 균형트리

## AVL 트리의 삽입 연산

삽입 후의 AVL 트리의 균형이 깨진 트리를 다시 균형 있게 만들려면 서브트리를 회전시켜야 합니다.

AVL 트리에서 균형이 깨지는 경우는 다음의 4가지 경우가 있습니다. 새로 삽입된 노드 N으로부터 가장 가까우면서 균형 인수가 ±2가 된 조상 노드를 A라고 하겠습니다.

1. **LL 타입**: N이 A의 왼쪽 서브트리의 왼쪽 서브트리에 삽입됩니다.
2. **LR 타입**: N이 A의 왼쪽 서브트리의 오른쪽 서브트리에 삽입됩니다.
3. **RR 타입**: N이 A의 오른쪽 서브트리의 왼쪽 서브트리에 삽입됩니다.
4. **RL 타입**: N이 A의 오른쪽 서브트리의 오른쪽 서브트리에 삽입됩니다.

각각의 경우를 균형 트리로 다시 만드는 방법은 다음과 같습니다.

- **LL 회전**: A부터 N까지의 경로상의 노드들을 오른쪽으로 회전시킵니다.
- **LR 회전**: A부터 N까지의 경로상의 노드들을 왼쪽-오른쪽으로 회전시킵니다.
- **RR 회전**: A부터 N까지의 경로상의 노드들을 왼쪽으로 회전시킵니다.
- **RL 회전**: A부터 N까지의 경로상의 노드들을 오른쪽-왼쪽으로 회전시킵니다.

한 번만 회전시키는 것을 **단순 회전 (single rotation)**이라고 하며, LL 회전과 RR 회전이 여기에 속합니다. 이 경우 탐색 순서를 유지하면서 부모와 자식의 위치를 교환하면 됩니다. 두 번의 회전이 필요한 경우 **이중 회전 (double rotation)**이라고 하며, LR 회전과 RL 회전이 여기에 속합니다. LL 회전과 RR 회전은 방향만 반대이고 대칭이며, LR 회전과 RL 회전 역시 방향만 반대이고 대칭입니다.






# AVL 트리 회전

## LL 회전

LL 타입은 조상 노드 A의 왼쪽 서브트리의 왼쪽 서브트리에 노드가 추가됨으로써 발생합니다.

![LL 회전](https://github.com/user-attachments/assets/58dc2df5-5139-4b1e-bac3-148d959d961c)

출처: 구글 LL회전

## RR 회전

RR 타입은 조상 노드 A의 오른쪽 서브트리의 오른쪽 서브트리에 노드가 추가됨으로써 발생합니다. 회전한다는 의미는 부모 노드와 자식 노드를 바꾼다는 것입니다.

![RR 회전](https://github.com/user-attachments/assets/0b0d09e6-e866-4afc-945b-16c169fd1b49)

출처: 구글 RR회전

## RL 회전

RL 타입은 조상 노드 A의 오른쪽 서브트리의 왼쪽 서브트리에 노드가 추가됨으로써 발생합니다. RL 회전은 균형 트리를 만들기 위하여 2번의 회전이 필요합니다. RL 회전은 LL 회전을 한 다음, RR 회전을 하면 됩니다.

![RL 회전](https://github.com/user-attachments/assets/b221b68e-835f-467a-bf23-dd590c35d30a)

출처: 구글 RL회전

## LR 회전

LR 타입은 조상 노드 A의 왼쪽 서브트리의 오른쪽 서브트리에 노드가 추가됨으로써 발생합니다. LR 회전은 균형 트리를 만들기 위하여 2번의 회전이 필요합니다. LR 회전은 RR 회전을 한 다음, LL 회전을 하면 됩니다.

![LR 회전](https://github.com/user-attachments/assets/eeee2dfb-87fe-4125-92e9-a9dce6723ab3)

출처: 구글 LR회전









# 해시

## 이론: 해시

### 참고: Hash function
A hash function is any algorithm or subroutine that maps large data sets of variable length, called keys, to smaller data sets of a fixed length.

## 이론: 해시 함수

### 출처: hash 함수 기본
- **Division**: 나머지 연산자(%)을 사용하여 나머지 값을 사용하는 방식. 아주 간단하지만 잘못된 값 선택 시 충돌 발생 가능성이 매우 높음. 일반적으로 소수를 사용함.
- **Mid Square**: 값을 제곱하여(square) 중간에 임의 값을(mid) 주소로 사용. 값이 조금만 틀려도 다른 값을 가질 확률이 높다.
- **Digit Analysis**: 데이터를 분석하여 고른 분포를 가지는 데이터 영역들을 선택하여 사용.
- **Folding**: 긴 데이터를 일정 크기로 나눠서 값을 더하거나 XOR한 값을 주소로 사용.
- **Radix Exchange**: 진법을 변환하거나 임의 진법이라 간주하여 변환된 값을 키로 사용.
- **Pseudo Random**: 임의 랜덤값을 사용.

## 이론: 충돌 해결법 (개방 주소법)

### 출처: Hash Function
- **개방 주소법 (Open Addressing)**: 빈 자리를 찾아 레코드를 이동하는 방식.
- **선형 탐색법 (Linear Probing)**: 비어 있는 주소가 발견될 때까지 차례차례 찾아가서 레코드를 삽입하는 방식. 클러스터링(Clustering) 유발.
- **2차 탐색법 (Quadratic Probing)**: 선형 탐색법의 클러스터링을 보완하기 위한 방식 (식: $h(k) + m^2$).
- **임의 탐색법 (Random Probing)**: 정해진 임의 수열에 의해 레코드를 이동하는 방식.
- **연쇄 방법 (Chaining Method)**: 포인터에 의해 각 버켓 레코드를 연결.
- **합병 연쇄 (Coalesced Chaining)**: 비어 있는 버켓에 충돌이 일으키는 레코드를 삽입하고 그 위치를 포인터로 기억시키는 방법.
- **분리 연쇄 (Separate Chaining)**: 각 버켓을 주소로 하는 레코드를 연결 리스트로 연결하고 그 헤더 포인터를 해시 테이블에 저장.
- **재해싱 (rehashing)**: 해시 함수를 다시 구성.




