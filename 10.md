탐색이란?

컴퓨터 프로그램에서 탐색은 하나 이상의 필드(field)로 구성되는 레코드(record)의 집합에서 원하는 레코드를 찾아내는 작업이다
이러한 레코드를 테이블(table)이라고 부른다.레코드들은 서로 중복되지 않고 고유한 값을 가지는 키를 가지는데, 이것을 탐색키(search key)라고 한다.
결국 자료를 검색하는 것은 테이블에서 원하는 탐색키를 가진 레코드를 찾는 것이다.

맵 이란?

맵은 탐색을 위한 자료구조이다. 맵(map)또는 사전(dictionary)은 자료를 저장하고 키를 이용해 원하는 자료를 빠르게 찾을 수 있도록 하는 자료구조를 말한다.
맵은 키를 가진 레코드(keyed record)또는 엔트리(entry)라 불리는 키-값 쌍(key,value)을 테이블에 저장한다.


Keyed Record

객체: 키(key)와 값(value)을 가진 요소 (key,value)의 집합
연산 create(key,value):주어진 key와 value를 각각 키와 값으로 갖는 레코드를 생성한다.
     getKey(): 레코들의 키를 반환한다.
     getValue(): 레코들의 값을 반환한다.
     update(value): 레코들의 값을 value로 변경한다.



Map

객체: 유일한 키를 가진 엔트리(키를 가진 레코드)의 집합
연산: create(): 공백 상태의 맵을 생성한다.
      search(key): 테이블에서 주어진 탐색 key를 가진 레코드를 찾아 반환한다.
      insert(entry): 테이블에서 주어진 entry를 삽입한다.
      delete(key): 테이블에서 주어진 탐색키 key를 가진 레코드를 찾아 삭제한다.
      count(): 테이블의 모든 레코드 수를 반환한다.



맵을 구현하는 가장 간단한 방법은 배열이다 하지만 맵의 탐색 성능을 고려하면 이진 탐색 트리와 같은 보다 효율적인 자료구조를 고려해야한다.
맵은 구현하는 4가지 방법이 있다.

(1)정렬되지 않은 배열을 사용하는 방법
(2)정렬된 배열을 이용하는 방법
(3)이진 탐색 트리를 이용하는 방법
(4)해싱을 이용하는 방법





정렬되지 않은 배열에서의 탐색

순차 탐색

순차탐색(sequential search)는 가장 간단하고 직접적인 탐색 방법이다.배열의 요소들을 처음부터 마지막까지 하나씩 검사하여 원하는 레코드를 찾는 방법이다.


```cpp

//int 배열 list의 순차탐색

int sequentialSearch(int list[], int key, int low, int high){

          for(int i=low;i<=high;i++)
                if(list[i]==key)
                   return i;          //탐색에 성공하면 키 값의 인덱스를 반환

         return -1;                  //탐색에 실패하면 -1을 반환

}

```





![Image](https://github.com/user-attachments/assets/ce79b365-2f71-4d87-ae31-772953d1ddd1)

출처: 구글 순차 탐색







정렬된 배열에서의 탐색

배열이 정렬되어 있으면 순차 탐색 실행 중에서 탐색키보다 큰 레코드를 만나면 탐색을 종료할 수 있으므로 배열 전체를 검색하지 않고도 탐색 항목의 존재 유무를 알 수 있다.


```cpp

//오름차순으로 정렬된 배열 list의 순차탐색
int sortedSequentialSearch(int list[], int key, int low, int high){

      int i;
      if(key<list[low] || key>list[high]) return -1;
      for(i=low; i<=high;i++){
          if(list[i]>key) return -1;
          if(list[i] ==key) return 1;
      }
}
```




정렬된 배열의 탐색에서는 이진 탐색(binary search)이 적용될 수 있다.이 방법은 배열의 중앙에 있는 값을 조사하여 찾고자 하는 항목이 왼쪽 부분 배열에 있는지 오른쪽 부분 배열에 있는지 판단하고 
다음 단계의 탐색 범위를 반으로 줄인다.따라서 매 단계에서 탐색해야 할 리스트의 크기가 반으로 줄어든다
이진 탐색하기 전에 반드시 배열이 정렬되어 있어야 한다.따라서 이진 탐색은 데이터의 삽입과 삭제가 빈번한 경우에는 적합하지 않다.

이진 탐색을 유사코드로 작성하면 list[low]부터 list[high] 사이에서 key를 찾는다고 가정하면 

```cpp

search_binary(list,low,high,key)

   middle <- low에서 high 사이의 중간의 위치
   if( 탐색값 = list[middle] )
         return middle;
   else if( 탐색값 < list[middle] )
         return search_binary(list,low,middle-1,key);
   else if( 탐색값 < list[middle] )
         return search_binary(list, middle+1,high,key);

   return -1

```





