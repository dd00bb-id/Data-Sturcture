# 정렬(Sorting)이란?

정렬(sorting)은 물건을 크기순으로 오름차순(ascending order)이나 내림차순(descending order)으로 나열하는 것을 의미합니다.  
정렬은 컴퓨터 공학 분야에서 가장 기본적이고 중요한 알고리즘 중의 하나로, 일상생활에서 많이 사용됩니다.

## 정렬 알고리즘의 분류

정렬 알고리즘은 크게 두 가지 분류로 나눌 수 있습니다:

1. **단순하지만 비효율적인 방법**  
   - 삽입정렬, 선택정렬, 버블정렬 등

2. **복잡하지만 효율적인 방법**  
   - 퀵 정렬, 힙 정렬, 합병 정렬, 기수 정렬 등

---

## 선택정렬(Selection Sort)

선택정렬(selection sort)은 오른쪽 리스트에서 가장 작은 숫자를 선택하여 왼쪽으로 이동하는 작업을 반복하여 오른쪽 리스트가 공백 상태가 될 때까지 되풀이하는 알고리즘입니다.

![선택정렬 과정](https://github.com/user-attachments/assets/eb5b6d1d-8d83-4175-985b-018c52f8c75f)

*출처: 구글 선택정렬의 과정*

### 선택정렬 유사 코드

요소의 개수가 `n`이면 최솟값을 찾고 교환하는 과정은 `n-1`번만 반복하면 됩니다.

```cpp
selectionSort(A, n) 
{
    for i <- 0 to n-1 do 
    {
        least <- A[i], A[i+1], ..., A[n-1] 중에서 가장 작은 값의 인덱스;
        A[i]와 A[least]의 교환;
        i++;
    }
}
```
# 선택 정렬의 시간복잡도 분석

선택 정렬의 **비교횟수**와 **이동횟수**를 따로 구해보겠습니다.

## 비교횟수

선택 정렬에서 비교는 두 개의 `for` 루프를 사용하여 이루어집니다.

1. **외부 루프**는 `n-1`번 반복됩니다.
2. **내부 루프**는 외부 루프에서 `i` 값에 따라 `(n-1)-i`번 반복됩니다.

이렇게 비교가 이루어지므로 전체 비교횟수는 다음과 같이 구할 수 있습니다.

\[
(n-1) + (n-2) + \dots + 1 = \frac{n(n-1)}{2} = O(N^2)
\]

따라서 선택 정렬의 **비교횟수**는 **O(N^2)**입니다.




# 삽입정렬 (Insertion Sort)

삽입정렬은 배열에서 정렬되지 않은 부분의 숫자를 정렬된 부분의 적절한 위치에 삽입하는 과정을 반복하여 정렬하는 알고리즘입니다. 삽입정렬은 단순하지만 직관적인 정렬 방식으로, 일반적으로 **배열이 거의 정렬되어 있을 때** 효율적입니다.

## 삽입정렬의 과정

1. **정렬되지 않은 부분**의 첫 번째 원소를 선택합니다.
2. 그 원소를 **정렬된 부분**에서 적절한 위치에 삽입합니다.
3. 이 과정을 배열의 모든 원소가 정렬될 때까지 반복합니다.

## 삽입정렬의 유사코드

```cpp
insertionSort(A, n) {
    for i = 1 to n-1 do {
        key = A[i];
        j = i - 1;
        
        while j >= 0 and A[j] > key do {
            A[j + 1] = A[j];
            j = j - 1;
        }
        
        A[j + 1] = key;
    }
}
```



## 버블 정렬 (Bubble Sort)

버블정렬(bubble sort)은 인접한 2개의 레코드를 비교하여 크기가 순서대로 정렬되어 있지 않으면 서로 교환(swap)하는 방법입니다.  
이것은 마치 물속에서 거품(bubble)이 보글보글 떠오르는 것과 유사하여 버블정렬이라고 합니다.

![버블정렬 과정](https://github.com/user-attachments/assets/3cc4ccfc-af80-44a6-8888-421f61412358)  

*출처: 구글 버블정렬의 과정*

### 버블정렬의 알고리즘
```cpp
BubbleSort(A,n)
for i<-n-1 to 1 do
     for j<-0 to i-1 do
          j와 j+1번째의 요소가 크기순이 아니면 교환
          j++;
       i--;
```

### 버블정렬의 시간 복잡도 분석

버블 정렬의 비교횟수는 최상, 평균, 최악의 어떤 경우에도 시간 복잡도는 O(N²)으로 항상 일정하고 같습니다.



### 셸 정렬 (Shell Sort)

셸 정렬은 전체 리스트를 한꺼번에 정렬하지 않습니다. 리스트를 일정한 기준에 따라 분류해 연속적이지 않은 여러 개의 부분 리스트를 만들고, 각 부분 리스트를 삽입 정렬을 이용하여 정렬합니다. 모든 부분 리스트가 정렬되면 셸 정렬은 다시 전체 리스트를 더 적은 개수의 부분 리스트로 만들어 앞의 과정을 반복합니다. 이 과정은 부분 리스트의 개수가 1이 될 때까지 반복됩니다.

#### 셸 정렬의 구현

`shellsSort()` 함수에서 변수 `gap`이 간격 k를 나타냅니다. `gap`이 1이 될 때까지 1/2로 줄이면서 반복합니다. 부분 리스트의 개수는 `gap`이 됩니다. 각 부분 리스트에 대하여 일정한 간격으로 떨어져 있는 요소들을 삽입 정렬하는 함수는 `sortGapInsertion()`입니다.

![Image](https://github.com/user-attachments/assets/b01646ab-4701-45ea-ba19-735df8be356c)
*출처: 구글 셸 정렬의 전체 과정*

#### 셸 정렬의 분석

삽입 정렬에 비하여 셸 정렬은 두 가지 장점이 있습니다:
1. 연속적이지 않은 부분 파일에서 자료의 교환이 일어나면 더 큰 거리를 이동합니다. 반면 삽입 정렬에서는 한 번에 한 칸씩만 이동됩니다. 따라서 교환되는 아이템들이 삽입 정렬보다는 최종 위치에 더 가까이 있을 가능성이 높아집니다.
2. 부분 리스트가 하나가 되면 셸 정렬은 전체 리스트를 정렬해야 합니다. 그러나 삽입 정렬이 거의 정렬된 리스트에 대해 매우 효율적이므로 이 과정도 빠르게 수행됩니다.

실험적인 연구를 통하여 셸 정렬의 시간 복잡도는 최악의 경우에는 O(N²)이지만 평균적인 경우에는 O(N^1.5)인 것으로 알려져 있습니다.




### 합병 정렬 (Merge Sort)

합병 정렬은 하나의 리스트를 두 개의 균등한 크기로 분할하고, 분할된 부분 리스트를 정렬한 다음, 두 리스트를 합하여 전체가 정렬된 리스트를 만드는 방법입니다. 이는 분할 정복 (divide and conquer) 기법에 바탕을 두고 있는데, 하나의 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략입니다. 분할 정복 기법은 대개 순환 호출을 이용하여 구현됩니다.

#### 합병 정렬의 단계

다음과 같은 배열이 있다고 가정해 보겠습니다:
        27 10 12 20 25 13 15 22

1. **분할 (Divide)**: 배열을 `27 10 12 20`과 `25 13 15 22`의 2개의 부분 배열로 나눕니다.
2. **정복 (Conquer)**: 부분 배열을 정렬하여 `10 12 20 27`과 `13 15 22 25`를 얻습니다.
3. **결합 (Combine)**: 부분 배열을 통합하여 `10 12 13 15 20 22 25 27`을 얻습니다.

각 부분 배열들을 정렬할 때는 순환을 사용하면 됩니다. 위의 예에서 부분 배열인 `27 10 12 20`을 정렬할 때도 합병 정렬 함수의 순환적으로 호출합니다. 부분 배열의 요소가 하나가 되면 이미 정렬된 것으로 볼 수 있습니다.

합병 정렬의 전체 과정을 그림으로 나타내면 아래와 같습니다.

![Image](https://github.com/user-attachments/assets/7a147d31-a46f-4a43-8d32-d38134bc0bca)
*출처: 구글 합병 정렬의 과정*

#### 합병 정렬의 알고리즘

```cpp

mergeSort(A, left, right)

if left<- right
   mid = (left+right)/2;
   mergeSort(A, left, mid);
   mergeSort(A, mid+1, right);
   merge(A, left, mid , right);



meger(A, left, mid, last)


b1<-left;
e1<-mid;
b2<-mid+1;
e2<-right;
sorted 배열을 생성;
index<-0;
while b1<=e1 and b2<=e2 do
   if(A[b1]<A[b2])
         then
             sorted[index]<-A[b1];
              b1++;
              index++;
          else
              sorted[index]<-A[b2];
              b2++;
              index++;
```


### 합병 정렬의 시간 복잡도 분석

합병 정렬의 시간 복잡도를 분석할 때, 하나의 합병 단계에서 임시 배열에 복사한 후 다시 가져와야 하므로 이동 연산이 발생합니다. 

- 만약 부분 배열에 들어있는 요소의 개수가 $n$인 경우, 레코드의 이동이 총 $2n$번 발생합니다. 
- 따라서 하나의 합병 단계에서 $2n$개의 이동 연산이 필요합니다.

합병 정렬은 $log_2 n$개의 합병 단계가 필요하므로, 총 이동 연산의 수는 $2n \cdot log_2 n$이 됩니다. 

결론적으로, 합병 정렬은 $O(n \log_2 n)$의 시간 복잡도를 가지는 알고리즘입니다.



### 퀵 정렬 (Quick Sort)

퀵 정렬은 평균적으로 매우 빠른 수행 속도를 자랑하는 정렬 방법입니다. 퀵 정렬도 합병 정렬과 같이 **분할 정복**(divide and conquer)을 사용합니다. 그러나 합병 정렬과 달리 리스트를 **균등하지 않게** 분할합니다.

1. 먼저 리스트 안에 있는 한 요소를 **피벗(pivot)**으로 선택합니다.
2. 리스트의 첫 번째 요소를 피벗으로 하고, 피벗보다 작은 요소들을 모두 피벗의 왼쪽으로 옮깁니다.
3. 피벗보다 큰 요소들을 모두 피벗의 오른쪽으로 옮깁니다.
4. 결과적으로 피벗을 중심으로 왼쪽은 피벗보다 작은 요소들로, 오른쪽은 피벗보다 큰 요소들로 구성됩니다.

이 상태에서 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬하게 되면 전체 리스트가 정렬됩니다.

![퀵 정렬 과정](https://github.com/user-attachments/assets/d1b8c978-34d8-44e7-8929-fac412dfd8f1)
*출처: 구글 퀵 정렬의 과정*



### 파티션 알고리즘 (Partition Algorithm)

퀵 정렬에서 가장 중요한 함수가 **파티션(partition)** 알고리즘입니다. 이 함수는 데이터가 들어 있는 배열 A의 `left`부터 `right`까지를 피벗을 기준으로 두 개의 부분 리스트로 나눕니다.

- **피벗보다 작은 데이터**는 모두 왼쪽 부분 리스트로 옮겨지고,
- **피벗보다 큰 데이터**는 모두 오른쪽 부분 리스트로 옮겨집니다.

#### 파티션 과정:
1. 피벗을 리스트의 첫 번째 데이터로 선택합니다.
2. 인덱스 `low`는 왼쪽 부분 리스트를 만드는 데 사용하고, `high`는 오른쪽 부분 리스트를 만듭니다.
3. `low`는 왼쪽에서 오른쪽으로 탐색하면서 피벗보다 큰 데이터를 찾습니다. 찾으면 멈추고,
4. `high`는 오른쪽 끝에서 왼쪽으로 탐색하면서 피벗보다 작은 데이터를 찾습니다. 찾으면 멈춥니다.
5. `low`와 `high`가 가리키는 데이터를 서로 교환합니다.
6. 이 과정을 `low`와 `high`가 엇갈리지 않을 때까지 반복합니다.

퀵 정렬의 전체 과정을 나타내면 아래 그림과 같습니다:

![퀵 정렬 전체 과정](https://github.com/user-attachments/assets/3d2a9e46-5725-4898-b7bf-661e0c28f668)
*출처: 구글 퀵 정렬의 전체 과정*

### 퀵 정렬의 시간 복잡도 분석

퀵 정렬의 시간 복잡도는 **분할**과 **정렬**에 따라 달라집니다.

- **최선의 경우**: 리스트가 거의 균등하게 분할될 때, 각 단계에서 `n`개의 요소를 다루며 `log_2 n`번의 분할을 하므로, 시간 복잡도는 `O(n log n)`입니다.
- **최악의 경우**: 리스트가 이미 정렬되어 있거나 역순으로 정렬되어 있을 때, 한쪽 리스트에 모든 요소가 쏠리게 되므로 `O(n^2)`의 시간이 걸립니다.
- **평균적인 경우**: 대부분의 경우, 퀵 정렬은 리스트를 거의 균등하게 분할하므로 평균적으로 `O(n log n)`의 시간 복잡도를 가집니다.

따라서, 퀵 정렬의 시간 복잡도는 평균적으로 `O(n log n)`이며, 최악의 경우에는 `O(n^2)`입니다.



