# 우선순위 큐 (Priority Queue)

## 개념
우선순위 큐(Priority Queue)는 각 요소에 우선순위(priority)가 부여된 큐입니다. 일반적인 큐에서는 FIFO(First-In-First-Out) 방식으로 데이터를 처리하지만, 우선순위 큐에서는 데이터가 우선순위에 따라 처리됩니다. 즉, 우선순위가 높은 데이터가 먼저 삭제되고 반환됩니다.

### 예시
도로에서 차량의 우선순위를 생각해보면, 구급차나 소방차는 일반 차량들보다 더 높은 우선순위를 가지고 있어, 다른 차들은 긴급 차량을 양보해야 합니다. 컴퓨터에서도 네트워크 패킷, 시스템 프로세스 등에서 우선순위를 갖는 요소들이 존재합니다.

## 스택, 큐, 우선순위 큐 비교

| 자료구조        | 삭제되는 요소               |
|-----------------|----------------------------|
| 스택 (Stack)    | 가장 최근에 들어온 데이터  |
| 큐 (Queue)      | 가장 먼저 들어온 데이터    |
| 우선순위 큐 (Priority Queue) | 가장 우선순위가 높은 데이터  |

## 우선순위 큐의 추상 자료형 (ADT)

우선순위 큐는 우선순위 값을 가진 요소들의 집합입니다. 주요 연산은 요소를 삽입하고 삭제하는 것입니다. 우선순위 큐는 두 가지 유형으로 나눌 수 있습니다:

- **최대 우선순위 큐**: 가장 우선순위가 높은 요소가 먼저 삭제됩니다.
- **최소 우선순위 큐**: 가장 우선순위가 낮은 요소가 먼저 삭제됩니다.

### 연산
- **insert(item)**: 우선순위 큐에 항목 item을 추가합니다.
- **remove()**: 우선순위 큐에서 가장 우선순위가 높은 요소를 삭제하고 반환합니다.
- **find()**: 우선순위가 가장 높은 요소를 삭제하지 않고 반환합니다.
- **isEmpty()**: 우선순위 큐가 비어있는지 확인합니다.
- **display()**: 우선순위 큐의 모든 요소들을 출력합니다.

## 우선순위 큐의 구현 방법

### 1. 배열을 사용하는 방법

#### 1.1 정렬되지 않은 배열
- **삽입**: 배열의 끝에 요소를 추가하면 되므로 시간 복잡도는 O(1)입니다.
- **삭제**: 가장 우선순위가 높은 요소를 찾기 위해 배열을 모두 탐색해야 하므로 시간 복잡도는 O(N)입니다.

#### 1.2 정렬된 배열
- **삽입**: 정렬된 배열에 삽입할 위치를 찾아야 하므로 시간 복잡도는 O(N)입니다.
- **삭제**: 가장 우선순위가 높은 요소를 삭제하는 것은 배열의 끝에서 삭제하면 되므로 시간 복잡도는 O(1)입니다.

### 2. 연결 리스트를 사용하는 방법

#### 2.1 정렬되지 않은 연결 리스트
- **삽입**: 첫 번째 노드로 삽입하면 되므로 시간 복잡도는 O(1)입니다.
- **삭제**: 가장 우선순위가 높은 요소를 찾기 위해 모든 노드를 탐색해야 하므로 시간 복잡도는 O(N)입니다.

#### 2.2 정렬된 연결 리스트
- **삽입**: 우선순위 값을 기준으로 적절한 위치를 찾아 삽입해야 하므로 시간 복잡도는 O(N)입니다.
- **삭제**: 우선순위가 가장 높은 요소를 삭제하는 것은 첫 번째 노드를 삭제하는 것이므로 시간 복잡도는 O(1)입니다.

### 결론
배열과 연결 리스트를 이용한 우선순위 큐의 시간 복잡도는 비슷합니다.

### 3. 힙(Heap)을 사용하는 방법

힙(Heap)은 우선순위 큐를 효율적으로 구현하기 위한 자료구조입니다. 힙은 완전 이진 트리로, 부모 노드의 값이 자식 노드의 값보다 크거나 작은 특성을 가지고 있습니다.

#### 3.1 힙의 종류
- **최대 힙 (Max-Heap)**: 부모 노드의 값이 자식 노드의 값보다 크거나 같은 이진 트리입니다.
- **최소 힙 (Min-Heap)**: 부모 노드의 값이 자식 노드의 값보다 작거나 같은 이진 트리입니다.

### 3.2 힙 트리의 구현 방법

힙은 완전 이진 트리이므로 배열을 이용해 효율적으로 구현할 수 있습니다.

#### 3.3 삽입 연산

힙에 새로운 요소를 삽입할 때는 새로운 노드를 힙의 마지막에 삽입한 후, 부모 노드와 비교하여 위치를 조정합니다. 이 과정은 최대 힙에서 부모 노드가 자식 노드보다 작을 때까지 계속됩니다.

```cpp

insert(key)

heapSize <- heapSize + 1;
i <- heapSize;
node[i] <- key;
while i != 1 and node[i] > node[PARENT(i)] do
      node[i] <-> node[PARENT(i)];
      i <- PARENT(i);
```
## 삭제 연산

힙에서 삭제 연산은 루트 노드를 삭제하는 과정입니다. 최대 힙에서는 루트 노드가 항상 최대값을 가지므로, 루트 노드를 삭제하고 힙을 재구성해야 합니다. 힙의 재구성이란 힙의 특성(부모 노드가 자식 노드보다 크거나 같은 최대 힙의 성질)을 만족하기 위해 노드를 교환하는 과정입니다.

### 삭제 과정

1. **루트 노드 삭제**: 루트 노드가 삭제됩니다. 루트 노드는 최대값을 가지므로, 이를 삭제한 후 힙을 재구성해야 합니다.
   
2. **마지막 노드 이동**: 루트 노드 자리에 힙의 마지막 노드를 가져옵니다. 이때 마지막 노드는 배열에서 가장 마지막 위치에 있는 요소입니다.

3. **힙 재구성**: 새로운 루트 노드와 그 자식 노드들을 비교하여, 힙의 특성을 만족할 수 있도록 교환합니다. 
    - 왼쪽 자식 노드와 비교한 후, 더 큰 값을 가진 자식 노드와 부모 노드를 교환합니다.
    - 이 과정을 자식 노드가 부모 노드보다 클 경우 반복하며 진행합니다.
    - 자식 노드가 부모 노드보다 작을 경우 교환을 중지하고, 힙의 재구성 과정이 끝납니다.


```cpp

remove()

item <- A[1];
A[i] <- A[heapSize];
heapSize <- heapSize-1;
i <- 2;
while i<= heapSize do
      if i < heapSize and A[LEFT(i)] > A[RIGHT(i)]
         then largest <- LEFT(i);
         else largest <- RIGHT(i);
      if A[PARENT(largest)] > A[largest]
         then break;
      A[PARENT(largest)] <-> A[largest];
      i <- LEFT(largest);
return item;
```


## 힙의 시간 복잡도 분석

힙에서의 주요 연산인 **삽입**과 **삭제**는 트리의 높이에 비례하여 시간이 소요됩니다. 이 과정에서 발생하는 연산들의 시간 복잡도를 분석해보겠습니다.

### 삽입 연산 시간 복잡도

삽입 연산에서는 새로운 요소가 힙 트리에 추가될 때, **상향식 힙화**(heapify-up) 과정이 수행됩니다. 새로운 요소는 힙 트리의 가장 마지막 위치에 삽입되며, 이 요소는 부모 노드와 비교하여 적절한 위치로 올라가야 합니다. 이 과정에서 필요한 연산은 비교 연산과 노드 교환입니다.

- 최악의 경우, 삽입된 노드는 루트 노드까지 올라가야 하므로, **트리의 높이만큼 비교 연산과 이동 연산**이 발생합니다.
- 힙이 **완전 이진 트리**이므로 트리의 높이는 `log N`에 비례합니다. 따라서 삽입 연산의 시간 복잡도는 **O(log N)**입니다.

### 삭제 연산 시간 복잡도

삭제 연산에서는 **루트 노드 삭제** 후, **하향식 힙화**(heapify-down) 과정이 진행됩니다. 루트 노드는 삭제된 후, 힙의 마지막 노드가 루트 자리에 들어갑니다. 이 새로운 루트 노드는 자식 노드들과 비교하여 적절한 위치로 내려가야 합니다.

- 최악의 경우, 새로운 루트 노드는 가장 아래 레벨까지 내려가야 하므로, **트리의 높이만큼 비교 연산과 노드 교환**이 발생합니다.
- 마찬가지로, 힙의 높이는 `log N`에 비례하므로 삭제 연산의 시간 복잡도도 **O(log N)**입니다.

### 결론

- **삽입 연산**: `O(log N)`
- **삭제 연산**: `O(log N)`

힙에서 삽입과 삭제 연산 모두 트리의 높이에 비례하는 시간 복잡도를 가지며, 힙이 **완전 이진 트리**이기 때문에 이들 연산의 시간 복잡도는 **O(log N)**으로 매우 효율적입니다.



      
