그래프란? 
그래프(graph)는 요소들이 서로 복잡하게 연결되어 있는 관계를 표현하는 자료구조이다.
그래프는 선형 자료구조들이나 트리보다 더 일반화 된 자료구조를 제공하고 많은 분야에서 널리 사용되고 있다.그래프는 정점(vertex)와 간선(edge)의 집합이다
정점은 노드(node)라고도 불리며, 간선은 링크(link)라고도 불린다.







그래프의 종류

무방향 그래프(undirected graph)

간선에 방향이 표시되지 않은 그래프를 무방향 그래프라고 한다.하나의 간선은 양방향으로 갈수 있는 길을 의미하고 (a,b)와 (b,a)는 동일한 간선이 된다.

방향 그래프(directed graph)

간선에 방향성이 존재하는 그래프를 방향 그래프라고 한다. 간선은 보통 화살표로 표시되는데 한쪽으로만 갈 수 있음을 의미한다.
정점a에서 정점b로 갈 수 있는 간선은 <a,b>로 표시한다

가중치 그래프(weighted graph)

간선에 비용이나 가중치가 할당된 그래프를 가중치 그래프 또는 네트워크(network)라 한다.간선은 두 정점간의 연결 유무뿐만 아니라 연결 강도까지 나타낼 수 있어 보다 복잡한 관계를 표현할 수 있다.

부분 그래프(subgraph)

그래프를 구성하는 정점의 집합과 간선의 집합의 부분 집합으로 이루어진 그래프를 부분 그래프라고 한다.








그래프의 용어

인접 정점(adjacent vertex):간선에 의해 직접 연결된 정점을 말한다.

정점의 차수(degree):그 정점에 연결된 간선의 수를 말한다.무방향 그래프에서는 모든 정점의 차수를 합하면 간선 수의 2배가 된다.하나의 간선이 두 개의 정점에 인접하기 때문이다.
                   방향 그래프에서는 외부에서 오는 간선의 수를 진입 차수(in-degree)라 하고 외부로 향하는 간선의 수를 진출 차수(out-degree)라 한다

경로(path):간선을 따라 갈 수 있는 길을 말하며 정점의 나열로 표시된다.

경로의 길이:경로를 구성하는 사용된 간선의 수를 말한다.

단순 경로(simple path)와 싸이클(cycle): 경로 중에서 반복되는 간선이 없는 경로를 단순 경로라 한다.단순 경로의 시작 정점과 종료 정점이 같다면 이러한 경로를 싸이클이라고 한다.


연결 그래프(connected graph): 그래프는 모든 정점들 사이에 경로가 존재하면 연결 그래프라고 라한다. 이그래프에는 떨어진 정점이 없다. 그렇지 않은 그래프를 비연결 그래프라한다.

트리(Tree): 그래프의 특수한 형태로 사이클을 가지지 않는 연결 그래프를 트리라한다.

완전 그래프(complete grapgh): 모든 정점 간에 간선이 존재하는 그래프를 완전 그래프라고 한다.








그래프의 추상 자료형

객체:정점의 집합과 간선의 집합

연산   create():그래프를 생성한다
       isEmpty():그래프가 공백 상태인지 확인한다
       insertVertex(v):그래프에 정점 v를 삽입한다.
       insertEdge(u,v):그래프에 간선 (u,v)를 삽입한다.
       deleteVertex(v):그래프에 정점 v를 삭제한다
       deleteEdge(u,v):그래프에 간선 (u,v)를 삭제한다.
       adjacent:정점 v에 인접한 모든 정점의 집합을 반환한다.








그래프의 표현 

컴퓨터에서 그래프를 표현하는 방법에는 배열을 사용하는 인접 행렬(adjacency matrix)과 연결 리스트를 사용하는 인접 리스트(adjacent list)의 두자지 방법이 있다.









인접 행렬을 이용한 그래프 표현
정점의 개수가 n이라면 n x n의 2차원 배열 형태인 인접 행렬이 사용된다.지금 다루는 그래프에서는 자체 간선(자신에서 출발하여 자신으로 돌아오는 간선)이 
존재하지 않으므로 인접 행렬의 대각선은 모두 0으로 표시한다.



인접 리스트를 이용한 그래프의 표현

인접 리스트(adjacency list)는 그래프의 각 정점에 인접한 정점들을 연결 리스트로 표현하는 방법이다. 연결 리스트의 노드들은 인접 정점 정보를 저장하는데 그래프에는
인접 리스트에 대한 헤더 포인터를 배열로 갖는다. 따라서 정점의 번호만 알면 각 정점의 연결 리스트에 쉽게 접근할 수 있다
무방향 그래프의 경우 간선(i,j)이 추가되면 정점 i의 연결 리스트에 j노드를 추가해야 하고 정점 j의 연결 리스트에도 i 노드를 추가해야 한다. 노드를 추가하는 방법에 따라
연결 리스트 내에서 정점들의 순서가 달라질 수 있지만 이러한 순서는 상관없다.








그래프의 탐색 

그래프의 탐색 기법은 깊이 우선 탐색과 너비 우선 탐색의 두 가지가 있다.

깊이 우선탐색(depth fisrt search, DFS):스택을 이용한 미로탐색과 유사하다.깊이 우선 탐색은 시작 정점에서부터 임의의 인접한 정점으로 깊이 탐색을 진행한다. 방문한 정점은 반드시 
방문되었다는 표시를 해야하고 탐색은 아직 방문하지 않은 인접 정점으로만 가능하다. 현재 정점에서 더 이상 방문하지 않은 인접 정점이 없으면 가장 마지막에 만났던 정점으로 돌아간다.
거기서 다시 아직 방문하지 않은 인접 정점을 찾아 다시 동일한 방법으로 탐색을 진행한다.스택없이 순환 알고리즘의 형태로 다음과 같이 간단하게 나타낼 수 있다.

```CPP

depthFisrtSearch(v)

v를 방문되었다고 표시;
for all u ㅌ (v에 인접한 정점) do
 if(u가 아직 방문되지 않았으면)
    then depthFisrtSearch(u)

```

너비 우선탐색(breadth first search, BFS)은 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다.
너비 우선 탐색을 위해서는 가까운 거리에 있는 정점들을 차례로 저장하고, 들어간 순서대로 꺼낼 수 있는 자료구조인 큐(queue)를 사용한다.즉 정점들이 방문될때마다
큐에 인접 정점과 인접한 정점들을 차례대로 방문한다.초기 상태의 큐에는 시작 정점만이 저장되고 너비 우선 탐색 과정은 큐가 공백 상태가 될때까지 계속한다.


```cpp

breadthFisrtSearch(v)

v를 방문되었다고 표시;
큐 Q에 정점 v를 삽입;
while (not is_empty(Q)) do
   Q에서 정점 w를 삭제;
   for all u ㅌ (w에 인접한 정점) do
       if(u가 아직 방문되지 않았으면)
            then u를 큐에 삽입;
                 u를 방문되었다고 표시;

```



신장 트리

신장 트리(spanning tree)란 그래프 내의 모든 정점을 포함하는 트리이다. 신장 트리도 트리의 일종이므로 모든 정점들이 연결되어 있고 사이클이 없어야 한다.


위상 정렬

방향 그래프에서 간선<u,v>가 있다면 "정점 u는 정점 v를 선행한다"고 말한다. 방향 그래프에 존재하는 각 정점들의 선행 순서를 위배하지 않으면서 모든 정점을 나열하는 것을 방향 그래프의 위상 정렬(topological sort)이라고 한다.







  
가중치 그래프란?

간선에 비용이나 가중치가 할당된 그래프를 가중치 그래프(weight graph)라고 한다.
가중치는 연결 정보뿐만 아니라 연결에 필요한 비용을 함께 표현할 수 있다.
가주치는 강도(weight), 비용(cost), 길이(length)라고 불린다.



가중치의 응용

인터넷 망과 같은 컴퓨터 네트워크를 표현하기 위해 그래프를 사용한다고 하자. 한 컴퓨터에서 다른 컴퓨터로 효율적으로 전송하기 위해서는 가장 빠른 길을 찾아야 하는데
어떤 연결부분은 전송 속도가 빠르지만 어떤 연결은 느릴수 있다. 이런경우 그래프의 모든 간선에 동일한 가중치가 아닌 다른 가중치를 부여함으로서 다른 빠른 패킷을 효율적으로
전송하기 위해 사용된다.




가중치 그래프의 표현

가중치가 없는 그래프에서는 인접 행렬의 값이 0 또는 1이었으며 두 정점 사이의 간선의 유무만 나타냈는데 가중치 그래프에서는 이 행렬의 값을 가중치로 나타내어 사용한다.







최소 비용 신장 트리

최소 비용 신장 트리란?

연결된 망을 가장 적은 비용으로 구축하고자 한다면, 네트워크에 있는 모든 정점들을 가장 적은 수의 간선과 비용으로 연결하는 것이 좋다.이때 최소 비용 신장 트리(MST: minimum spanning tree)가 필요하다.
이 트리는 신장 트리들 중에서 사용된 간선들의 가중치 합이 최소인 신장 트리를 말한다.
최소 비용 신장 트리를 구하는 방법에는 크루스칼(Kruskal)알고리즘이 있다.



Kruskal의 MST 알고리즘
kruskal 알고리즘은 탐욕적인 방법(greedy method)이라는 알고리즘 설계에서 가장 중요한 기법을 사용한다. 이것은 어떤 결정을 해야 할 떄마다 "매 순간에 최적"을 선택하는 방법이다
물론 매순간 최선이라고 생각했던 선택을 모아 최종적인 최적이되는지는 보장되지 않는다. 따라서 탐욕적인 방법은 항상 최적의 해답을 주는지를 반드시 검증해야된다.
각 단계에서 사이클을 이루지 않는 최소 비용 간선을 선택한다. 이러한 과정을 반복하여 그래프의 모든 정점을 최소비용으로 연결하는 최적 해답을 구한다.


```
Kruskal()

1.그래프의 모든 간선을 가중치에 따라 오름차순으로 정렬한다.
2.가장 가중치가 작은 간선 e를 뽑는다
3.e를 신장 트리에 넣을 경우 싸이클이 생기면 삽입하지 않고 2번으로 이동한다.
3.사이클이 생기지 않으면 최소 신장 트리에 삽입한다.
4.n-1개의 간선이 삽입될때까지 2번으로 이동한다.

```

![Image](https://github.com/user-attachments/assets/05415789-8710-4097-b2d8-bcfe5c90f005)

이미지 추러: 구글 크루스칼 알고리즘 동작의 예





union-find 연산

사이클 검사를 위해 union-find의 union(x,y)은 원소x와 y가 속해있는 집합을 입력으로 받아 이들의 합집합을 만드는 연산이다.find(x)연산은 여러 집합들 중에서 원소x가 속해있는 집합을 반환하는 연산이다.
트리를 이용하여 하나의 트리가 하나의 집합을 나타내고 트리의 노드들이 집합의 원소가 된다.집합은 트리의 루트에 의하여 대표된다.


![Image](https://github.com/user-attachments/assets/481e31a6-cbdf-4536-b6b5-2c928aaac360)

이미지 출처: 구글 union 연산의 예




 

