# 리스트란?

리스트는 선형 자료구조로 항목들이 일렬로 순서대로 나열된 것을 의미합니다. 리스트는 스택, 큐와 같이 배열을 사용할 수도 있고, 포인터를 이용한 연결 리스트를 구현할 수도 있습니다. 배열을 이용할 경우 리스트 ADT를 가장 간단하게 구현할 수 있지만, 스택이나 큐에서와 같이 리스트에 저장할 수 있는 요소의 개수에 제한이 생깁니다. 

만약 리스트를 위해 아주 큰 배열을 사용한다면 요소를 많이 넣을 수 있지만, 메모리 낭비의 비효율을 감수해야 합니다. 배열로 리스트를 구현할 때 삽입과 삭제 시 발생하는 문제들로 인해 많은 요소들을 이동해야 하는 문제가 생길 수 있습니다. 실제 프로그래밍에서 사용하는 리스트는 대부분 포인터를 사용한 연결 리스트 방식을 사용합니다.




## 연결리스트란?

연결리스트는 데이터 필드와 주소 필드로 이루어진 상자들이 줄로 연결되어 이루어진 것입니다.

![연결리스트 구조](https://github.com/user-attachments/assets/84de9280-44c7-4881-aae4-a75fa45503b8)

_이미지 출처: [구글 연결리스트]_

## 노드 (Node)

앞 그림에서의 상자를 컴퓨터 용어로 노드(Node)라고 부릅니다. 일반적인 노드는 그림과 같이 데이터 필드(data field)와 링크 필드(linked field)로 구성됩니다. 

- **데이터 필드**에는 우리가 저장하고 싶은 자료가 저장됩니다. 이것은 정수가 될 수도 있고, 클래스 객체와 같은 복잡한 자료형이 될 수도 있습니다.
- **링크 필드**에는 다른 노드를 가리키는 포인터 변수가 있습니다. 이 포인터를 이용하여 현재 노드에 연결된 다음 노드를 알 수 있습니다.

![node](https://github.com/user-attachments/assets/e464b898-973d-432c-b4ff-62a088f2acd1)

_이미지 출처: [구글 연결리스트]_

## 헤드 포인터 (Head Pointer)

연결 리스트는 첫 번째 노드를 알면 링크로 매달려 있는 모든 노드에 접근할 수 있습니다. 따라서 연결 리스트에는 첫 번째 노드를 가리키는 포인터가 필요한데, 이를 **헤드 포인터(head pointer)**라고 합니다.

연결 리스트의 마지막 노드는 더 이상 연결할 노드가 없기 때문에 링크 필드의 값을 `NULL`로 설정하여 이 노드가 마지막 노드임을 나타냅니다.

![헤드 포인터](https://github.com/user-attachments/assets/74de9712-bb5b-4680-bddb-37364d5bdc84)

_이미지 출처: [구글 헤드포인터]_

## 연결리스트의 종류

연결 리스트에는 다음과 같은 3가지 종류가 있습니다:

1. **단순 연결리스트(Singly Linked List)**  
   - 하나의 방향으로만 연결되어 있으며, 맨 마지막 노드의 링크 필드는 `NULL` 값을 가집니다.
   
2. **원형 연결 리스트(Circular Linked List)**  
   - 단순 연결 리스트와 같지만, 맨 마지막 노드의 링크 값이 다시 첫 번째 노드를 가리킵니다.
   
3. **이중 연결 리스트(Doubly Linked List)**  
   - 각 노드마다 링크 필드(포인터)가 2개씩 존재합니다. 이를 통해 각각의 노드는 선행 노드와 후속 노드를 모두 가리킬 수 있습니다.


![연결리스트의 종류](https://github.com/user-attachments/assets/6fd86113-b935-4986-b3b4-30b463abbbe9)
                                     
_이미지 출처: [구글 연결리스트의 종류]_

## 리스트의 추상자료형

- **객체**: 임의의 접근 방법을 제공하는 같은 타입의 요소들의 순서 있는 모임

### 연산

- **insert(pos, item)**: 리스트의 `pos` 위치에 새로운 요소 `item`을 삽입
- **delete(pos)**: 리스트의 `pos` 위치에 있는 요소를 삭제
- **isEmpty()**: 리스트가 비어있는지 검사
- **isFull()**: 리스트가 가득 차 있는지 검사
- **size()**: 리스트 안의 요소의 개수를 반환
- **display()**: 리스트 안의 모든 요소를 출력
- **find(item)**: 리스트에 요소 `item`이 있는지 확인
- **getEntry(pos)**: 리스트의 `pos` 위치에 있는 요소를 반환
- **replace(pos, item)**: 리스트의 `pos` 위치에 있는 요소를 새로운 요소 `item`으로 바꿈










## 주요 연산

### 1. 삽입 연산

리스트에 새로운 노드를 삽입하는 방법을 생각해봅니다. 그림과 같이 연결된 노드 사이에 새로운 노드를 삽입하고자 할 때, 두 가지 단계가 필요합니다. 먼저 삽입하기 전의 노드를 각각 `A`, `B`라고 하고, 삽입할 노드를 `N`이라고 합시다. 

- **첫 번째 단계**: 노드 `N`이 노드 `B`를 가리키게 합니다.
- **두 번째 단계**: 노드 `A`가 노드 `N`을 가리키게 해야 합니다.

![연결리스트 삽입](https://github.com/user-attachments/assets/916825f0-1ad9-4a68-abff-c8c6f7a4d05f)

_이미지 출처: [구글 연결리스트의 삽입]_

### 코드 예시

```cpp
class Node {
    Node* link; // 다음 노드를 가리키는 포인터 변수
    int data;   // 노드의 데이터 필드
};

// 리스트의 pos 위치에 노드 삽입
void insert(int pos, Node* n) {
    Node* prev = getEntry(pos - 1);
    if (prev != NULL) {
        prev->insertNext(n);
    }
}
```



### 리스트가 공백 상태일 경우 삽입 처리

리스트가 **공백 상태**라면, 간단하게 **헤드 포인터**가 새로운 노드를 가리키게 하면 됩니다. 

- **공백 상태가 아닐 경우**에는 위와 같은 방법으로 링크를 수정해야 합니다.

#### 코드 예시

```cpp
insert(before, node)

if (isEmpty()) {
    head <- node;  // 리스트가 비어있다면 헤드 포인터가 새로운 노드를 가리킴
} else {
    node.link <- before.link;  // 새로운 노드가 기존 노드를 가리키도록 함
    before.link <- node;       // before 노드가 새로운 노드를 가리키도록 수정
}

```














### 2. 삭제 연산

삭제 연산은 그림에서 **before**와 **after** 사이에 있는 **removed** 노드를 삭제하는 방법을 보여줍니다. 

- **삭제 전**: `a` 상태는 삭제되기 전의 연결리스트 모습입니다.
- **삭제 후**: `b` 상태는 삭제된 후의 연결리스트 모습입니다.

삭제는 단순히 **before** 노드가 **after** 노드를 가리키도록 변경하는 것입니다. 전체 노드의 연결은 **before**에서 바로 **after**로 넘어가므로, **removed**의 링크가 **after**를 가리키고 있는 것은 무시해도 됩니다.

![연결리스트 삭제](https://github.com/user-attachments/assets/7a92d85d-c746-4688-ba9a-7b5de59c6e51)

_이미지 출처: [구글 연결리스트의 삭제]_

### 코드예시 

```cpp
class Node {
    Node* link; // 다음 노드를 가리키는 포인터 변수
    int data;   // 노드의 데이터 필드
};
Node* remove(int pos){
Node* prev = getEntry(pos-1);
return prev->removeNext();
}
```



### 리스트가 공백 상태일 경우 삭제 처리

리스트가 **공백 상태**라면 삭제할 수 없습니다. 공백 상태가 아니면, **before**의 다음 노드 주소를 **removed** 변수에 복사하고, **before**의 다음 노드를 **removed**의 다음 노드로 변경합니다. 연결리스트에서는 모든 노드가 동적으로 생성되었으므로, **removed** 노드에 대한 삭제도 뒤따라야 합니다.

#### 코드 예시

```cpp
remove(before)

if (isEmpty() == false) {
    removed <- before.link;        // before의 다음 노드 주소를 removed에 저장
    before.link <- removed.link;   // before 노드가 removed의 다음 노드를 가리키게 함
    destroy(removed);              // removed 노드를 삭제
}

```

### 삭제 연산 시 중요한 점

위 알고리즘에서 **removed 노드를 삭제**하려고 할 때, **removed**가 아닌 **before**를 매개변수로 전달해야 한다는 점에 유의해야 합니다. 그 이유는 **removed**의 선행 노드 정보(즉, 링크 필드)가 변경되어야 하기 때문입니다.

#### 선행 노드 정보 변경

단순 연결 리스트에서 각 노드는 **후속 노드의 주소**만을 가지고 있으며, **선행 노드**는 알 수 없습니다. 따라서 **삭제할 노드**를 찾으려면 **삭제할 노드의 선행 노드**를 알아야 합니다.

- **삭제할 노드를 알면** 해당 노드를 직접 삭제할 수 없고, **삭제할 노드의 선행 노드**를 찾아야만 연결을 변경할 수 있습니다.
- 이 과정에서 **before** 노드가 **removed**의 선행 노드가 되어야 하며, **before**의 링크 필드를 수정하여 **removed** 노드를 삭제하는 방식으로 연산이 이루어집니다.




